java的一大优势是语言层面支持多线程。大多基于synchronization: 在多线程间协调和数据获取。Java用于支持同步的机制是monitor。

# monitors

​      一个监视器(monitor)支持两种线程同步： <u>**互斥和协作**</u>。jvm通过对象锁支持排他,使得多线程可以在共享数据上独立工作而互相不影响。jvm通过Object类的wait和notify方法支持协作，使得线程朝着同一个目标一起工作。

​      Monitor好比是一个包含一个特殊房间的建筑，这个特殊房间同时只能有一个线程可以占用。在线程进入这个房间直到离开这段时间里，这个线程对房间内的数据都具有排他获取性。”进入这个特殊的房间“被称为获取monitor。 “占用房间“称为持有monitor，“离开房间”称为释放monitor。离开整个建筑称为退出monitor。

​     除了和数据关联，monitor也和一些称为监视区的代码关联。对于一个监视器来说，监视区域是最小的、不可分割的代码块，也就是说在同一个监视器中，监视区域只会同时被一个线程执行。一个线程想要进入监视器的唯一途径就是到达该监视器锁关联的一个监视区域的开始处，而线程想要继续执行监视区域的唯一途径就是获取该监视器。

​     当一个线程到达临界区，就被放入相应监视器的入口区(entry set)。入口区就好像是监视器前面的走廊，如果入口区没有其他线程，且没有其他线程占有这个监视器，当前线程获取锁并执行临界区。当线程完成临界区的执行就会退出并且释放监视器。

​     如果线程进入一个被其他线程占有的监视器的临界区，那么它必须在入口区等待。当线程退出监视器后，入口区内等待的线程将会竞争获取锁，只有一个能成功。

​     前面提到的第一种同步-——互斥，可以在多线程环境中互斥地执行一段监视区代码。 监视器支持的另一种同步是协作。互斥帮助线程在共享数据时不被其他线程干扰，而协作帮助线程与其他线程共同工作。

​     当一个线程需要一些 特别状态的数据，而由另一个线程负责改变这些数据的状态时，同步就显得特别重要。JVM使用的这种监视器被称作“等待唤醒”监视器。在这种监视器中，一个已经持有监视器的线程，可以通过执行一个等待命令，暂停自身的执行。当线程执行了等待命令后，将释放监视器并进入一个等待区，这个线程会在等待区一致持续暂停状态，直到这个监视器中的其他线程执行了唤醒命令。当一个线程执行了唤醒命令后，会继续持有监视器并执行监视区的代码，直到它主动释放监视器。 

​     被唤醒的线程需要再次检查数据的状态是否是自己需要的状态，否则可能会再次等待而进入等待区。

JVM使用的监视器如图所示：

<img src="../../../../../../Library/Application Support/typora-user-images/image-20200314141447494.png" alt="image-20200314141447494" style="zoom:50%;" />

​       这个图显示了线程与监视器交互需要通过的几个门，当线程到达监视区的开始处时，会通过1号门进入入口区，如果入口区没有线程，且监视区没有被占有，则通过2号门进入监视区并持有监视器，作为监视器的持有者继续执行监视区中的代码。  另一种情况， 如果监视区已经被占有了，那么它就只能在入口区中阻塞并等待。

​       监视器的所有者线程有两种方式释放监视器，一种是执行完监视区中的代码从5号门退出并释放监视器，另一种是主动调用等待命令从3号门进入等待区并释放监视器。如果这个所有者释放监视器前没有执行唤醒命令，那么位于入口区中的那些线程将会竞争获得监视器。反之，如果所有者释放监视器之前执行了唤醒命令，等待区中的线程也会参与这场竞争。如果等待区中的线程竞争成功，则会通过4号门进入监视区成为监视器新的持有者。

​       线程执行等待命令时可以指定一个等待时间，超时后即使没有其他线程来唤醒它，它也会从虚拟机得到一个自动唤醒命令。  JVM提供了两种唤醒命令：notify和notifyall 。 Notify 随意从等待区中将一个线程标记为"可能苏醒"，而notifyall命令将等待区中的所有线程都标记成“可能苏醒”。 我们尽量使用notifyall而不要使用notify，因为notify很可能按照某种优先级永远不苏醒优先级低的线程。

#   对象锁

​       JVM中，每个对象和类在逻辑上都是和一个监视器相关联的，而对于对象来说，相关联的监视器保护对象的实例变量，对于类来说，监视器保护类的变量。如果一个对象没有实例变量，或者一个类没有类变量，相关联的监视器就什么都不监视。

​       为了实现监视器的排他性监视能力，JVM为每一个对象和类都关联一个锁(有时被称为互斥体mutex) 。 一个锁就像一种任何时候只允许一个线程拥有的特权。 线程访问实例变量或者类变量不需要获取锁。但是如果线程获取了锁，那么在它释放这个锁之前，就没有其他线程可以获取同样数据的锁了(锁住一个对象就是获取对象相关联的监视器)

​	  一个线程可以允许多次对同一个对象上锁。对于每一个对象来说，JVM维护一个计数器，记录对象被加了多少次锁。没有被锁的对象的计数器是0. 

​      JVM中的一个线程到达监视区开始处时请求一个锁，有两种监视区：同步语句和同步方法。 每一个监视区域都和一个对象引用相关联。 当一个线程到达监视区的第一条指令的时候，线程必须对该引用对象加锁，否则线程不允许执行其中的代码。     

​       对象锁是JVM内部使用的，我们只需要编写同步语句或同步方法就可以标志一个监视区，每一次进入监视区都会自动锁上对象或者类。

# 指令集对同步的支持

synchronized关键字，底层使用monitorenter和monitorexit两个操作指令，JVM遇到monitorenter时，获得对象锁，锁计数器加1，monitorexit会引起计数器减1，计数器变成0就代表监视器被释放了。

# Object类中的协调支持

Object的wait/wait(long)/notify/notifyAll等方法

# 互斥的方案

互斥的本质就是阻止多个进程同时进入临界区

## 信号量

首先需要明白的一点是，信号量的出现是为了解决什么问题，由于一个进程的阻塞和唤醒是在不同的进程中造成的，比如说进程 A 调用了 sleep() 会进入阻塞，而进程 B 调用 wakeup（A）会把进程 A 唤醒。因为是在不同的进程中进行的，所以也存在着被中断的问题。加入进程 A 根据逻辑，需要调用 sleep() 进入阻塞状态，然而，就在它调用 sleep 方法之前，由于时钟中断，进程 B 开始运行了，根据逻辑，它调用了 wakeup() 方法唤醒进程 A，可是由于进程 A 还未进入阻塞状态，因此这个 wakeup 信号就丢失了，等待进程 A 从之前中断的位置开始继续运行时并进入阻塞后，可能再也没有进程去唤醒它了。
因此，进程的阻塞和唤醒，应该需要额外引进一个变量来记录，这个变量记录了唤醒的次数，每次被唤醒，变量的值加1。有了这个变量，即使wakeup操作先于sleep操作，但wakeup操作会被记录到变量中，当进程进行sleep时，因为已经有其它进程唤醒过了，此时认为这个进程不需要进入阻塞状态。
这个变量，在操作系统概念中，则被称为**信号量（semaphore**），由 Dijkstra 在 1965 年提出的一种方法。
对信号量有两种操作， down 和 up。
down 操作实际上对应着 sleep，它会先检测信号量的值是否大于0，若大于0，则减1，进程此时无须阻塞，相当于消耗掉了一次 wakeup；若信号量为0，进程则会进入阻塞状态。
而 up 操作对应着 wakeup，进行 up 操作后，如果发现有进程阻塞在这个信号量上，那么系统会选择其中一个进程将其唤醒，此时信号量的值不需要变化，但被阻塞的进程已经少了一个；如果 up 操作时没有进程阻塞在信号量上，那么它会将信号量的值加1。
有些地方会把 down 和 up 操作称之为 PV 操作，这是因为在 Dijkstra 的论文中，使用的是 P 和 V 分别来代表 down 和 up。
信号量的 down 和 up 操作，是操作系统支持的原语，它们是具有原子性的操作，不会出现被中断的情况。

## 互斥量

互斥量（mutex）其实是信号量的一种特例，它的值只有 0 和 1，**当我们不需要用到信号量的计数能力时，我们可以使用互斥量，实际上也意味着临界区值同一时间只允许一个进程进入，而信号量是允许多个进程同时进入临界区的。**

