1. 进程是可以并发运行的，即使只有一个 CPU 的时候）
2. 操作系统的时钟中断会引起进程运行的重新调度，
3. 除了时钟中断，来自其它设备的中断也会引起进程运行的重新调度

一个小例子🌰：

一个文件中保存了一个数字 n，进程 A 和进程 B 都想要去读取这个文件的数字，并把这个数字加 1 后，保存回文件。假设 n 的初始值是 0，在我们理想的情况下，进程 A 和进程 B 运行后，文件中 n 的值应该为 2，但实际上可能会发生 n 的值为 1。我们可以考量一下，每个进程做这件事时，需要经过什么步骤：

1. 读取文件里 n 的值
2. 令 n = n + 1
3. 把新的 n 值保存回文件。

唯一能让 n = 2 的方法，只能期望进程 A 和进程 B **按顺序**分别完整地运行完所有步骤。

# 竞态条件：

两个或者多个进程读写某些共享数据，而最后的结果取决于进程运行的准确时序，称为竞态条件。

# 互斥与临界区

如何避免 race condition，我们需要以某种手段，确保当一个进程在使用一个共享变量或者文件时，其它的进程不能做同样的操作，换言之，我们需要“互斥”。
以上述例子作为例子，我们可以把步骤 1 - 3 这段程序片段定义为临界区，临界区意味着这个区域是敏感的，因为一旦进程运行到这个区域，那么意味着会对公共数据区域或者文件进行操作，也意味着有可能有其它进程也正运行到了临界区。如果能够采用适当的方式，使得这两个进程不会同时处于临界区，那么就能避免竞态条件。
也就是，我们需要想想怎么样做到“互斥”。

# 互斥的方案

互斥的本质就是阻止多个进程同时进入临界区

## 信号量

首先需要明白的一点是，信号量的出现是为了解决什么问题，由于一个进程的阻塞和唤醒是在不同的进程中造成的，比如说进程 A 调用了 sleep() 会进入阻塞，而进程 B 调用 wakeup（A）会把进程 A 唤醒。因为是在不同的进程中进行的，所以也存在着被中断的问题。加入进程 A 根据逻辑，需要调用 sleep() 进入阻塞状态，然而，就在它调用 sleep 方法之前，由于时钟中断，进程 B 开始运行了，根据逻辑，它调用了 wakeup() 方法唤醒进程 A，可是由于进程 A 还未进入阻塞状态，因此这个 wakeup 信号就丢失了，等待进程 A 从之前中断的位置开始继续运行时并进入阻塞后，可能再也没有进程去唤醒它了。
因此，进程的阻塞和唤醒，应该需要额外引进一个变量来记录，这个变量记录了唤醒的次数，每次被唤醒，变量的值加1。有了这个变量，即使wakeup操作先于sleep操作，但wakeup操作会被记录到变量中，当进程进行sleep时，因为已经有其它进程唤醒过了，此时认为这个进程不需要进入阻塞状态。
这个变量，在操作系统概念中，则被称为**信号量（semaphore**），由 Dijkstra 在 1965 年提出的一种方法。
对信号量有两种操作， down 和 up。
down 操作实际上对应着 sleep，它会先检测信号量的值是否大于0，若大于0，则减1，进程此时无须阻塞，相当于消耗掉了一次 wakeup；若信号量为0，进程则会进入阻塞状态。
而 up 操作对应着 wakeup，进行 up 操作后，如果发现有进程阻塞在这个信号量上，那么系统会选择其中一个进程将其唤醒，此时信号量的值不需要变化，但被阻塞的进程已经少了一个；如果 up 操作时没有进程阻塞在信号量上，那么它会将信号量的值加1。
有些地方会把 down 和 up 操作称之为 PV 操作，这是因为在 Dijkstra 的论文中，使用的是 P 和 V 分别来代表 down 和 up。
信号量的 down 和 up 操作，是操作系统支持的原语，它们是具有原子性的操作，不会出现被中断的情况。

## 互斥量

互斥量（mutex）其实是信号量的一种特例，它的值只有 0 和 1，当我们不需要用到信号量的计数能力时，我们可以使用互斥量，实际上也意味着临界区值同一时间只允许一个进程进入，而信号量是允许多个进程同时进入临界区的。

